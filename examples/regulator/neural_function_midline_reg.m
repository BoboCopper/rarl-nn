function [Y,Xf,Af] = neural_function_midline_reg(X,Xi,~)
%NEURAL_FUNCTION_MIDLINE_REG neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 14-Jul-2017 09:09:04.
% 
% [Y,Xf,Af] = neural_function_midline_reg(X,Xi,~) takes these arguments:
% 
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = 3xQ matrix, input #1 at timestep ts.
% 
%   Xi = 1x4 cell 1, initial 4 input delay states.
%   Each Xi{1,ts} = 3xQ matrix, initial states for input #1.
% 
%   Ai = 3x0 cell 3, initial 4 layer delay states.
%   Each Ai{1,ts} = 10xQ matrix, initial states for layer #1.
%   Each Ai{2,ts} = 5xQ matrix, initial states for layer #2.
%   Each Ai{3,ts} = 1xQ matrix, initial states for layer #3.
% 
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = 1xQ matrix, output #1 at timestep ts.
% 
%   Xf = 1x4 cell 1, final 4 input delay states.
%   Each Xf{1,ts} = 3xQ matrix, final states for input #1.
% 
%   Af = 3x0 cell 3, final 0 layer delay states.
%   Each Af{1ts} = 10xQ matrix, final states for layer #1.
%   Each Af{2ts} = 5xQ matrix, final states for layer #2.
%   Each Af{3ts} = 1xQ matrix, final states for layer #3.
% 
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-27.781;-1.6707;-0.30478];
x1_step1.gain = [0.0327659365323809;0.80681598141096;2.96081363158596];
x1_step1.ymin = -1;

% Layer 1
b1 = [-1.4890604730635704;3.3617291147217818;-2.7382582626346381;0.49908283561916073;0.47292179845610621;-0.11891133014984963;0.55397448063110155;-2.4615122471972302;-0.13016252029572761;-3.7322217988228275];
IW1_1 = [0.10377640311205855 -0.20247225863702334 0.33163535665795923 -0.2138964536115765 -0.28040935504306713 -0.083782859074205615 -0.5252896400710072 -0.23023409588052404 0.63451507095925497 -0.24132997379296292 0.77421811762892812 0.021869149738362216;-1.5980011153915474 -1.3834273519853924 -0.29145863756727097 -0.77195392797134565 -0.86071537677556853 0.58346538734233633 -0.17601637308644766 -0.71778408383294412 -0.19202674869942787 -0.084073194267635709 -0.32405951125036581 -0.020553229842031583;-1.5989973477380759 -1.2148157025066011 -1.4899002241556549 -0.4836335603189435 -1.0774154319848472 -1.504642660263543 0.28134282993603926 -0.86250845475468207 -0.023306942198690544 1.4971790231459192 0.29279472346604535 1.0718792336351735;0.58930285240519586 0.40796150679659055 0.36520745240925584 0.68652397546989297 0.4308184555204676 0.56596376347528266 -0.13598717977918309 -0.42673350993058695 -0.59670485533751194 -0.28567841167031621 -0.24306962530320897 -1.0380623827113444;-1.9554663659879004 -0.50454305730017557 -1.4591256785320132 -0.3572044862549843 -0.32115404545853243 0.0089019635039855292 1.1175788240043929 1.0299298747895995 0.54871665170562944 1.0040444016249881 2.0644124834551811 1.2534861042315892;3.802476146369417 2.3540370525187071 0.47567090218507552 1.4956161283831069 1.3164708027323813 -0.076300759585165537 -2.0931830956345672 -0.85751819239363081 -0.52408797817533892 -3.0196618977787457 -2.4971123927496541 0.27518976002459056;2.9655350258616817 1.9059622172782562 0.86491574404859894 0.46166090741220428 0.66203971131327799 0.85899508768116606 -1.2286106973697708 -0.32633938618812747 -0.045235711939338556 -2.8112612713149834 -2.5000815845532158 -1.2809054321634381;0.2229320062577046 0.33063762692700521 0.52644378102197165 0.58748014178703556 -0.35871067979566368 0.8345849047357593 -0.59859013721587895 0.25261627082996635 0.061094190457522318 -0.14611924582578442 -0.43700733635867206 -0.77398951990889731;-1.6326052948982579 -1.1305273447085007 0.21967086371356062 -0.20499406858129826 -0.66955750725521368 0.064334950206782801 -0.049876429475939982 0.57265545245577576 0.60499309102358068 1.911310348637755 1.5359753143113757 -0.58657094621227523;0.32939624014517949 0.97777954554842961 -0.029446298411421871 -0.51416390697319503 0.40577274334507735 -0.23632813122423268 -0.86997985991194704 -0.7516811396616675 0.50943538767196983 -1.1578875552676653 -0.21872970646267353 0.33738831707557659];

% Layer 2
b2 = [0.59428406001261402;-0.71809158032714693;-0.073759938055915214;0.55536298090769987;0.60680543304457846];
LW2_1 = [0.37302892676930266 -0.7316688924125202 -0.75022756929659207 -0.98048343551276373 0.30148396817964479 2.9256263426935951 -0.67240679551203519 0.53110575141741401 -1.9271271000151715 -0.97396410370468045;0.55260238255037819 -0.92590504024373199 -0.31441600703458961 -1.0658238663128856 0.082496809527343104 -0.75204632324754284 -1.364937996439199 -0.014518042463238111 1.7834944964561834 1.7700408870551041;0.61419586745501753 -0.1921971261317508 -0.11650113107792767 -3.5483856720380924 -0.062391904466767664 -1.946838542013051 -2.4476825819551937 1.76995642368483 1.2188199112499118 0.71596687739620657;-0.17530911915673847 -0.35206988786999655 0.00734100140011479 0.086817819196726209 -0.15003773377778015 -1.2131696560673315 -1.7861483195064023 1.5384983394387395 -1.7229833652885649 -0.70812432932023883;0.1638860896198783 0.31163477860612171 0.85277563499699927 0.43323601032728526 -0.31814896302267359 2.0819443873824821 1.8549820053733417 -0.028118236080073907 -2.1773365917634733 0.66010425170622777];

% Layer 3
b3 = -1.6231531473785445;
LW3_2 = [2.6613929274732264 0.62245750408160772 -1.3550167653405716 -0.48075916927864154 2.958178959069635];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = 0.0204956312098103;
y1_step1.xoffset = -62.0459142857143;

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
  X = {X};
end
if (nargin < 2), error('Initial input states Xi argument needed.'); end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
  Q = size(X{1},2); % samples/series
elseif ~isempty(Xi)
  Q = size(Xi{1},2);
else
  Q = 0;
end

% Input 1 Delay States
Xd1 = cell(1,5);
for ts=1:4
    Xd1{ts} = mapminmax_apply(Xi{1,ts},x1_step1);
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+3,5)+1;
    
    % Input 1
    Xd1{xdts} = mapminmax_apply(X{1,ts},x1_step1);
    
    % Layer 1
    tapdelay1 = cat(1,Xd1{mod(xdts-[1 2 3 4]-1,5)+1});
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*tapdelay1);
    
    % Layer 2
    a2 = tansig_apply(repmat(b2,1,Q) + LW2_1*a1);
    
    % Layer 3
    a3 = repmat(b3,1,Q) + LW3_2*a2;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a3,y1_step1);
end

% Final Delay States
finalxts = TS+(1: 4);
xits = finalxts(finalxts<=4);
xts = finalxts(finalxts>4)-4;
Xf = [Xi(:,xits) X(:,xts)];
Af = cell(3,0);

% Format Output Arguments
if ~isCellX
  Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
